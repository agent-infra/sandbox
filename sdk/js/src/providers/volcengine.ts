/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { BaseProvider, SandboxResponse } from './base';
import { request } from './sign';

/**
 * Volcengine cloud provider implementation for sandbox management.
 *
 * This provider uses the Volcengine VEFAAS (Volcengine Function as a Service)
 * API to manage sandbox instances.
 */
export class VolcengineProvider extends BaseProvider {
    private accessKey: string;
    private secretKey: string;
    private region: string;
    private clientSideValidation: boolean;

    /**
     * Initialize the Volcengine provider.
     *
     * @param accessKey - Volcengine access key ID
     * @param secretKey - Volcengine secret access key
     * @param region - Volcengine region, defaults to "cn-beijing"
     * @param clientSideValidation - Enable client-side validation, defaults to true
     */
    constructor(
        accessKey: string,
        secretKey: string,
        region: string = 'cn-beijing',
        clientSideValidation: boolean = true
    ) {
        super();
        this.accessKey = accessKey;
        this.secretKey = secretKey;
        this.region = region;
        this.clientSideValidation = clientSideValidation;
    }

    /**
     * Create a new sandbox instance using Volcengine VEFAAS.
     *
     * @param functionId - The function ID for the sandbox
     * @param kwargs - Additional parameters for sandbox creation (timeout, etc.)
     * @returns The ID of the created sandbox or the exception raised
     */
    async createSandbox(functionId: string, kwargs: Record<string, any> = {}): Promise<SandboxResponse> {
        try {
            const timeout = kwargs.timeout || 30;
            const body = {
                function_id: functionId,
                timeout: timeout,
                ...kwargs,
            };

            const response = await this._makeRequest('CreateSandbox', body);
            return response.sandbox_id;
        } catch (e) {
            return e;
        }
    }

    /**
     * Delete an existing sandbox instance.
     *
     * @param functionId - The function ID of the sandbox
     * @param sandboxId - The ID of the sandbox to delete
     * @param kwargs - Additional parameters for sandbox deletion
     * @returns The response containing deletion status
     */
    async deleteSandbox(functionId: string, sandboxId: string, kwargs: Record<string, any> = {}): Promise<SandboxResponse> {
        try {
            const body = {
                function_id: functionId,
                sandbox_id: sandboxId,
                ...kwargs,
            };

            const response = await this._makeRequest('KillSandbox', body);
            return response;
        } catch (e) {
            return e;
        }
    }

    /**
     * Get details of an existing sandbox instance.
     *
     * @param functionId - The function ID of the sandbox
     * @param sandboxId - The ID of the sandbox to retrieve
     * @param kwargs - Additional parameters for sandbox retrieval
     * @returns The response containing sandbox details
     */
    async getSandbox(functionId: string, sandboxId: string, kwargs: Record<string, any> = {}): Promise<SandboxResponse> {
        try {
            const body = {
                function_id: functionId,
                sandbox_id: sandboxId,
                ...kwargs,
            };

            const response = await this._makeRequest('DescribeSandbox', body);
            const baseDomains = await this.getApigDomains(functionId);
            const domainsStruct = this._appendInstanceQueryStruct(baseDomains, sandboxId);

            return {
                ...response,
                domains: domainsStruct,
            };
        } catch (e) {
            return e;
        }
    }

    /**
     * List all sandbox instances for a function.
     *
     * @param functionId - The function ID to list sandboxes for
     * @param kwargs - Additional parameters for listing sandboxes
     * @returns The response containing list of sandboxes
     */
    async listSandboxes(functionId: string, kwargs: Record<string, any> = {}): Promise<SandboxResponse> {
        try {
            const body = {
                function_id: functionId,
                ...kwargs,
            };

            const response = await this._makeRequest('ListSandboxes', body);
            const baseDomains = await this.getApigDomains(functionId);

            const sandboxes = response.sandboxes || [];
            const normalized = sandboxes.map((sb: any) => {
                const instanceId = sb.id || sb.sandbox_id;
                const domainsStruct = instanceId
                    ? this._appendInstanceQueryStruct(baseDomains, instanceId)
                    : baseDomains;

                return {
                    ...sb,
                    domains: domainsStruct,
                };
            });

            return normalized;
        } catch (e) {
            return e;
        }
    }

    /**
     * Append ?faasInstanceName= to domain field of structured domain objects, preserving type.
     */
    private _appendInstanceQueryStruct(
        domainsInfo: Array<{ domain?: string; Domain?: string; type?: string; Type?: string }>,
        instanceName: string
    ): Array<{ domain: string; type?: string }> {
        const result: Array<{ domain: string; type?: string }> = [];

        for (const info of domainsInfo) {
            const domainStr = info.domain || info.Domain || '';
            if (!domainStr) {
                continue;
            }

            const newDomain = domainStr.includes('?')
                ? `${domainStr}&faasInstanceName=${instanceName}`
                : `${domainStr}?faasInstanceName=${instanceName}`;

            result.push({
                domain: newDomain,
                type: info.type || info.Type,
            });
        }

        return result;
    }

    /**
     * Get the UpstreamId from APIG triggers for a given function.
     */
    private async _getApigTrigger(functionId: string): Promise<string | null> {
        const body = {
            FunctionId: functionId,
        };

        const now = new Date();
        const response = await request('POST', now, {}, {}, this.accessKey, this.secretKey, '', 'ListTriggers', JSON.stringify(body));

        if (response && typeof response === 'object') {
            const result = response.Result || {};
            const items = result.Items || [];

            for (const item of items) {
                if (item.Type === 'apig') {
                    const detailedConfig = item.DetailedConfig || '{}';
                    try {
                        const config = JSON.parse(detailedConfig);
                        const upstreamId = config.UpstreamId;
                        if (upstreamId) {
                            return upstreamId;
                        }
                    } catch (e) {
                        console.error(`Failed to parse DetailedConfig: ${detailedConfig}`);
                        continue;
                    }
                }
            }
        }

        return null;
    }

    /**
     * Get structured domains from APIG routes using the upstream ID.
     */
    private async _getApigDomains(upstreamId: string): Promise<Array<{ domain: string; type?: string }>> {
        const body = {
            UpstreamId: upstreamId,
            PageSize: 100,
            PageNumber: 1,
        };

        const now = new Date();
        const response = await request('POST', now, {}, {}, this.accessKey, this.secretKey, '', 'ListRoutes', JSON.stringify(body));

        const domains: Array<{ domain: string; type?: string }> = [];

        if (response && typeof response === 'object') {
            const result = response.Result || {};
            const routes = result.Items || [];

            for (const route of routes) {
                let pathPrefix = '';
                try {
                    const matchRule = route.MatchRule || {};
                    const pathRule = matchRule.Path || {};
                    const matchContent = pathRule.MatchContent;
                    if (typeof matchContent === 'string') {
                        pathPrefix = matchContent;
                    }
                } catch (e) {
                    pathPrefix = '';
                }

                const routeDomains = route.Domains || [];
                for (const domainInfo of routeDomains) {
                    const base = domainInfo.Domain;
                    if (!base) {
                        continue;
                    }

                    domains.push({
                        domain: `${base}${pathPrefix}`,
                        type: domainInfo.Type || domainInfo.type,
                    });
                }
            }
        }

        return domains;
    }

    /**
     * Get domains for APIG triggers of a given function.
     */
    async getApigDomains(functionId: string): Promise<Array<{ domain: string; type?: string }>> {
        const upstreamId = await this._getApigTrigger(functionId);
        if (upstreamId) {
            return await this._getApigDomains(upstreamId);
        }
        return [];
    }

    /**
     * Create an application using Volcengine VEFAAS.
     */
    private async _createApplication(name: string, gatewayName: string, kwargs: Record<string, any> = {}): Promise<string | null> {
        const functionName = `${name}-function`;
        const sid = Math.floor(Math.random() * 10000000).toString().padStart(7, '0');

        const body = {
            Name: name,
            Config: {
                region: 'cn-beijing',
                functionName: functionName,
                gatewayName: gatewayName,
                sid: sid,
            },
            TemplateId: '68ad2fb0443cb8000843cbbe',
        };

        const now = new Date();
        try {
            const response = await request(
                'POST',
                now,
                {},
                {},
                this.accessKey,
                this.secretKey,
                '',
                'CreateApplication',
                JSON.stringify(body)
            );

            if (typeof response !== 'object') {
                console.error('CreateApplication returned non-object response:', response);
                return null;
            }

            const result = response.Result;
            if (typeof result !== 'object') {
                console.error('CreateApplication response missing Result:', response);
                return null;
            }

            const applicationId = result.Id;
            if (!applicationId) {
                console.error('CreateApplication response missing Result.Id:', response);
                return null;
            }

            return applicationId;
        } catch (e) {
            console.error('CreateApplication request failed:', e);
            return null;
        }
    }

    /**
     * Release an application using Volcengine VEFAAS.
     */
    private async _releaseApplication(id: string, kwargs: Record<string, any> = {}): Promise<any> {
        const body = { Id: id };
        const now = new Date();
        const response = await request(
            'POST',
            now,
            {},
            {},
            this.accessKey,
            this.secretKey,
            '',
            'ReleaseApplication',
            JSON.stringify(body)
        );
        return response;
    }

    /**
     * Create an application using Volcengine VEFAAS.
     */
    async createApplication(name: string, gatewayName: string, kwargs: Record<string, any> = {}): Promise<string | null> {
        if (!name) {
            throw new Error('name is required to create an application');
        }
        if (!gatewayName) {
            throw new Error('gateway_name is required to create an application');
        }

        const applicationId = await this._createApplication(name, gatewayName, kwargs);
        if (!applicationId) {
            return null;
        }

        try {
            await this._releaseApplication(applicationId, kwargs);
        } catch (e) {
            console.error(`ReleaseApplication request failed for id ${applicationId}:`, e);
        }

        return applicationId;
    }

    /**
     * Return readiness flag and function ID when available.
     */
    async getApplicationReadiness(id: string, kwargs: Record<string, any> = {}): Promise<[boolean, string | null]> {
        const body = { Id: id };
        const now = new Date();

        try {
            const response = await request(
                'POST',
                now,
                {},
                {},
                this.accessKey,
                this.secretKey,
                '',
                'GetApplication',
                JSON.stringify(body)
            );

            if (typeof response !== 'object') {
                console.error('GetApplication returned non-object response:', response);
                return [false, null];
            }

            const result = response.Result;
            if (typeof result !== 'object') {
                console.error('GetApplication response missing Result:', response);
                return [false, null];
            }

            let functionId: string | null = null;
            const cloudResourceRaw = result.CloudResource;

            if (typeof cloudResourceRaw === 'string') {
                try {
                    const cloudResource = JSON.parse(cloudResourceRaw);
                    if (typeof cloudResource === 'object') {
                        functionId = cloudResource.function_id;
                        if (!functionId) {
                            const sandboxInfo = cloudResource.sandbox;
                            if (typeof sandboxInfo === 'object') {
                                functionId = sandboxInfo.function_id;
                            }
                        }
                    }
                } catch (e) {
                    console.error(`Failed to decode CloudResource for application ${id}:`, e);
                }
            } else if (typeof cloudResourceRaw === 'object') {
                functionId = cloudResourceRaw.function_id;
            }

            const status = result.Status;
            const isReady = status === 'deploy_success';

            if (!isReady) {
                console.log(`Application ${id} not ready. Status: ${status}`);
                return [false, functionId];
            }

            return [true, functionId];
        } catch (e) {
            console.error(`GetApplication request failed for id ${id}:`, e);
            return [false, null];
        }
    }

    /**
     * Make a generic request to Volcengine VEFAAS API
     */
    private async _makeRequest(action: string, body: Record<string, any>): Promise<any> {
        const now = new Date();
        const response = await request(
            'POST',
            now,
            {},
            {},
            this.accessKey,
            this.secretKey,
            '',
            action,
            JSON.stringify(body),
            this.region
        );
        return response;
    }
}
